<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>20x20 Random Maze Game</title>
    <style>
        canvas {
            border: 1px solid black;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        #instructions {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="mazeCanvas" width="400" height="400"></canvas>
    <div id="instructions">Use arrow keys to move. Reach the red exit!</div>
    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 20;
        const cellSize = canvas.width / gridSize;
        let maze = [];
        let player = { x: 1, y: 1 };
        let exit = { x: 19, y: 19 };

        // Initialize maze with walls
        function initMaze() {
            maze = [];
            for (let y = 0; y < gridSize; y++) {
                let row = [];
                for (let x = 0; x < gridSize; x++) {
                    row.push({ walls: [true, true, true, true], visited: false }); // top, right, bottom, left
                }
                maze.push(row);
            }
        }

        // Generate maze using depth-first search
        function generateMaze() {
            initMaze();
            let stack = [];
            let current = { x: 1, y: 1 };
            maze[current.y][current.x].visited = true;
            stack.push(current);

            while (stack.length > 0) {
                let neighbors = getUnvisitedNeighbors(current.x, current.y);
                if (neighbors.length > 0) {
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    removeWall(current, next);
                    maze[next.y][next.x].visited = true;
                    stack.push(next);
                    current = next;
                } else {
                    current = stack.pop();
                }
            }
        }

        // Get unvisited neighbors of a cell
        function getUnvisitedNeighbors(x, y) {
            let neighbors = [];
            const directions = [
                { x: 0, y: -1, wall: 0, oppWall: 2 }, // up
                { x: 1, y: 0, wall: 1, oppWall: 3 },  // right
                { x: 0, y: 1, wall: 2, oppWall: 0 },  // down
                { x: -1, y: 0, wall: 3, oppWall: 1 }   // left
            ];

            for (let dir of directions) {
                let nx = x + dir.x;
                let ny = y + dir.y;
                if (nx > 0 && nx < gridSize - 1 && ny > 0 && ny < gridSize - 1 && !maze[ny][nx].visited) {
                    neighbors.push({ x: nx, y: ny, wall: dir.wall, oppWall: dir.oppWall });
                }
            }
            return neighbors;
        }

        // Remove walls between two cells
        function removeWall(current, next) {
            maze[current.y][current.x].walls[next.wall] = false;
            maze[next.y][next.x].walls[next.oppWall] = false;
        }

        // Draw the maze
        function drawMaze() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let cell = maze[y][x];
                    let px = x * cellSize;
                    let py = y * cellSize;

                    ctx.beginPath();
                    if (cell.walls[0]) { // top
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + cellSize, py);
                    }
                    if (cell.walls[1]) { // right
                        ctx.moveTo(px + cellSize, py);
                        ctx.lineTo(px + cellSize, py + cellSize);
                    }
                    if (cell.walls[2]) { // bottom
                        ctx.moveTo(px, py + cellSize);
                        ctx.lineTo(px + cellSize, py + cellSize);
                    }
                    if (cell.walls[3]) { // left
                        ctx.moveTo(px, py);
                        ctx.lineTo(px, py + cellSize);
                    }
                    ctx.stroke();
                }
            }

            // Draw player
            ctx.fillStyle = 'blue';
            ctx.fillRect(player.x * cellSize + 2, player.y * cellSize + 2, cellSize - 4, cellSize - 4);

            // Draw exit
            ctx.fillStyle = 'red';
            ctx.fillRect(exit.x * cellSize + 2, exit.y * cellSize + 2, cellSize - 4, cellSize - 4);
        }

        // Handle player movement
        function movePlayer(dx, dy) {
            let newX = player.x + dx;
            let newY = player.y + dy;

            if (newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) return;

            // Check if movement is blocked by a wall
            if (dx === 1 && maze[player.y][player.x].walls[1]) return; // moving right
            if (dx === -1 && maze[player.y][player.x].walls[3]) return; // moving left
            if (dy === 1 && maze[player.y][player.x].walls[2]) return; // moving down
            if (dy === -1 && maze[player.y][player.x].walls[0]) return; // moving up

            player.x = newX;
            player.y = newY;

            drawMaze();

            // Check for win condition
            if (player.x === exit.x && player.y === exit.y) {
                setTimeout(() => {
                    alert('Congratulations! You reached the exit!');
                    resetGame();
                }, 100);
            }
        }

        // Reset game
        function resetGame() {
            player = { x: 1, y: 1 };
            generateMaze();
            drawMaze();
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                    movePlayer(1, 0);
                    break;
            }
        });

        // Start the game
        generateMaze();
        drawMaze();
    </script>
</body>
</html>
